<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Charge Jump: Ngựa Chiến</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0f17;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block;width:100vw;height:100vh;touch-action:none}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ====== Resize (hiDPI) ======
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
  }
  addEventListener("resize", resize);
  resize();

  // ====== Assets ======
  const horseImg = new Image();
  horseImg.src = "horse.svg";

  const fenceImg = new Image();
  fenceImg.src = "fence.svg";

  const wingsImg = new Image();
  wingsImg.src = "wings.svg";

  // ====== Audio ======
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let isMuted = false;

  function playTone(freq, type, duration, startTime = 0, vol = 0.1) {
    if (isMuted || audioCtx.state === 'suspended') return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime + startTime);
      gain.gain.setValueAtTime(vol, audioCtx.currentTime + startTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + startTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(audioCtx.currentTime + startTime);
      osc.stop(audioCtx.currentTime + startTime + duration);
    } catch(e){}
  }

  function sfxJump() {
    if (isMuted) return;
    playTone(200, "sine", 0.1, 0, 0.1); 
  }

  function sfxCrash() {
    if (isMuted) return;
    playTone(100, "sawtooth", 0.3, 0, 0.2);
  }

  function startBGM() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }

  // ====== Constants ======
  const G = 2200;               
  const GROUND_H = 110;         
  const PLAYER_R = 18;          
  const BASE_JUMP = 650;        
  const MAX_CHARGE = 1.35;      
  const CHARGE_MULT = 1.6;      
  const SPEED_BASE = 420;       
  const SPEED_GAIN = 12;        
  const OBSTACLE_GAP_MIN = 360;
  const OBSTACLE_GAP_MAX = 760;

  // ====== State ======
  let tPrev = performance.now();
  let running = true;
  let gameOver = false;
  let inMenu = true;

  const state = {
    score: 0,
    best: parseInt(localStorage.getItem('chargeJumpBest')) || 0,
    timeAlive: 0,
    speed: SPEED_BASE,
    shake: 0,
    distance: 0
  };

  const ui = {
    startBtn: { x: 0, y: 0, w: 200, h: 60, text: "BẮT ĐẦU" },
    replayBtn: { x: 0, y: 0, w: 200, h: 60, text: "CHƠI LẠI" }
  };

  const player = {
    x: 140,
    y: 0,
    vy: 0,
    onGround: true,
    charging: false,
    chargeT: 0,
    blinkTimer: 0,
    isBlinking: false,
    canDoubleJump: true,
    hasShield: false
  };

  // ====== Entities ======
  const obstacles = [];
  const items = [];
  const particles = [];
  const footprints = [];

  // ====== Helper Functions ======
  function rand(a,b){ return a + Math.random()*(b-a); }
  function groundY() { return innerHeight - GROUND_H; }

  function spawnObstacle(initial=false) {
    // Grid System: 1 unit = 64px
    const BLOCK_SIZE = 64;
    const cols = Math.floor(Math.random() * 2) + 1; // 1 or 2 blocks wide
    let rows = Math.floor(Math.random() * 3) + 1; // 1 to 3 blocks high
    
    // Logic: Tránh 2 cột cao giống nhau (>= 2 khối) ở sát nhau
    const lastOb = obstacles[obstacles.length - 1];
    if (lastOb) {
        const lastRows = lastOb.h / BLOCK_SIZE;
        if (lastRows >= 2 && rows === lastRows) {
            // Nếu trùng độ cao >= 2, đổi sang độ cao khác (ưu tiên về 1 cho dễ chơi)
            rows = 1;
        }
    }
    
    const w = cols * BLOCK_SIZE;
    const h = rows * BLOCK_SIZE;
    
    // Position logic to prevent pop-ins
    let x;
    if (initial) {
        x = innerWidth + rand(100, 300);
    } else {
        // Calculate gap
        let gapMin = OBSTACLE_GAP_MIN;
        let gapMax = OBSTACLE_GAP_MAX;

        // NẾU LÀ CỘT CAO (3 KHỐI) -> TĂNG KHOẢNG CÁCH
        // Để người chơi có thời gian chuẩn bị nạp lực
        if (rows === 3) {
            gapMin += 300; 
            gapMax += 450;
        }

        const nextX = (lastOb ? lastOb.x + lastOb.w : innerWidth) + rand(gapMin, gapMax);
        x = Math.max(innerWidth + 50, nextX);
    }

    obstacles.push({ x, w, h, y: groundY() - h, passed: false });
  }

  function spawnDust(x, y) {
    const count = rand(1, 2);
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x + rand(-10, 10),
        y: y + rand(-5, 5),
        vx: -state.speed + rand(-50, 50),
        vy: rand(-50, -150),
        life: 1.0,
        size: rand(2, 5),
        color: `rgba(180, 160, 140, ${rand(0.4, 0.8)})`
      });
    }
  }

  function reset() {
    gameOver = false;
    state.score = 0;
    state.timeAlive = 0;
    state.speed = SPEED_BASE;
    state.shake = 0;
    state.distance = 0;

    player.x = 140;
    player.y = groundY() - PLAYER_R;
    player.vy = 0;
    player.onGround = true;
    player.charging = false;
    player.chargeT = 0;
    player.blinkTimer = rand(2, 4);
    player.canDoubleJump = true;
    player.hasShield = false;

    obstacles.length = 0;
    items.length = 0;
    particles.length = 0;
    footprints.length = 0;
    
    spawnObstacle(true);
  }

  // ====== Update ======
  function update(dt) {
    if (!running || inMenu) return;

    if (!gameOver) {
      state.timeAlive += dt;
      state.speed = SPEED_BASE + state.score * SPEED_GAIN;
      state.distance += state.speed * dt;

      // --- Particles ---
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt * 2;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // --- Footprints ---
      for (let i = footprints.length - 1; i >= 0; i--) {
        footprints[i].x -= state.speed * dt;
        if (footprints[i].x < -20) footprints.splice(i, 1);
      }
      if (player.onGround) {
         spawnDust(player.x - 10, player.y + PLAYER_R - 5);
         const lastFp = footprints[footprints.length - 1];
         if (!lastFp || (player.x - lastFp.x > 40)) { 
             footprints.push({ x: player.x, y: groundY() });
         }
      }

      // --- Player Logic ---
      // Charging
      if (player.charging) {
        player.chargeT += dt;
        if (player.chargeT > MAX_CHARGE) player.chargeT = MAX_CHARGE;
      }
      // Blinking
      player.blinkTimer -= dt;
      if (player.blinkTimer <= 0) {
        if (player.isBlinking) {
          player.isBlinking = false;
          player.blinkTimer = rand(2, 5);
        } else {
          player.isBlinking = true;
          player.blinkTimer = 0.15;
        }
      }

      // Physics
      player.vy += G * dt;
      player.y += player.vy * dt;
      
      // Ground Check
      const gy = groundY() - PLAYER_R;
      if (player.y >= gy) {
        player.y = gy;
        player.vy = 0;
        player.onGround = true;
        player.canDoubleJump = true;
      } else {
        player.onGround = false;
      }

      // --- Obstacles ---
      // Move & Score
      for (const o of obstacles) {
        o.x -= state.speed * dt;
        if (!o.passed && o.x + o.w < player.x - PLAYER_R) {
          o.passed = true;
          state.score += 1;
        }
      }
      // Remove off-screen
      if (obstacles.length > 0 && obstacles[0].x + obstacles[0].w < -100) {
        obstacles.shift();
      }
      // Spawn Logic (Fix Pop-in)
      const lastOb = obstacles[obstacles.length - 1];
      if (!lastOb || lastOb.x + lastOb.w < innerWidth + 100) {
          spawnObstacle(lastOb ? false : true);
      }

      // --- Collision ---
      for (let i = 0; i < obstacles.length; i++) {
        const o = obstacles[i];
        function circleRect(cx, cy, r, rx, ry, rw, rh) {
            const nx = Math.max(rx, Math.min(cx, rx + rw));
            const ny = Math.max(ry, Math.min(cy, ry + rh));
            const dx = cx - nx, dy = cy - ny;
            return (dx*dx + dy*dy) <= r*r;
        }

        if (circleRect(player.x, player.y, PLAYER_R, o.x, o.y, o.w, o.h)) {
          gameOver = true;
          if (state.score > state.best) {
             state.best = state.score;
             localStorage.setItem('chargeJumpBest', state.best);
          }
          state.shake = 14;
          sfxCrash();
          break;
        }
      }
    }

    state.shake = Math.max(0, state.shake - 40 * dt);
  }

  // ====== Draw ======
  function drawButton(btn, y) {
    const x = (innerWidth - btn.w) / 2;
    btn.drawY = y; 
    ctx.fillStyle = "#2563eb";
    ctx.strokeStyle = "#60a5fa";
    ctx.lineWidth = 4;
    const r = 10;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + btn.w - r, y);
    ctx.quadraticCurveTo(x + btn.w, y, x + btn.w, y + r);
    ctx.lineTo(x + btn.w, y + btn.h - r);
    ctx.quadraticCurveTo(x + btn.w, y + btn.h, x + btn.w - r, y + btn.h);
    ctx.lineTo(x + r, y + btn.h);
    ctx.quadraticCurveTo(x, y + btn.h, x, y + btn.h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "bold 24px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(btn.text, x + btn.w / 2, y + btn.h / 2 + 2);
    ctx.textAlign = "start"; ctx.textBaseline = "alphabetic"; 
  }

  function draw() {
    const w = innerWidth, h = innerHeight;
    let sx = 0, sy = 0;
    if (state.shake > 0) {
      sx = (Math.random() - 0.5) * state.shake;
      sy = (Math.random() - 0.5) * state.shake;
    }
    ctx.save();
    ctx.translate(sx, sy);

    // BG Color
    let bg = "#0b0f17";
    if (state.score >= 10 && state.score < 20) bg = "#4c1d95"; 
    else if (state.score >= 20 && state.score < 30) bg = "#0ea5e9"; 
    else if (state.score >= 30) bg = "#be123c"; 
    ctx.fillStyle = bg;
    ctx.fillRect(-50, -50, w+100, h+100);

    // Stars
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#cfe8ff";
    for (let i=0;i<60;i++){
      const x = (i*97 + (state.timeAlive*120)) % (w+40) - 20;
      const y = (i*53) % (h-160) + 30;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // Mountains
    ctx.fillStyle = "#162035";
    const mountainScroll = state.distance * 0.2;
    ctx.beginPath();
    ctx.moveTo(0, h);
    for (let i = -50; i <= w + 50; i += 50) {
       const mx = i;
       const my = h - 200 - Math.sin((mx + mountainScroll) * 0.005) * 50 - Math.cos((mx + mountainScroll) * 0.01) * 30;
       ctx.lineTo(mx, my);
    }
    ctx.lineTo(w + 50, h);
    ctx.lineTo(-50, h);
    ctx.fill();

    // Ground
    const gy = groundY();
    ctx.fillStyle = "#121a2a";
    ctx.fillRect(0, gy, w, GROUND_H);
    ctx.fillStyle = "#1f2b44";
    ctx.fillRect(0, gy, w, 3);

    // Footprints
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    for (const fp of footprints) {
       ctx.beginPath();
       ctx.ellipse(fp.x, fp.y + 2, 8, 3, 0, 0, Math.PI*2);
       ctx.fill();
    }

    // Obstacles (Tiled 64px Grid)
    for (const o of obstacles) {
      if (fenceImg.complete) {
        const size = 64; 
        const cols = o.w / size;
        const rows = o.h / size;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
             ctx.drawImage(fenceImg, o.x + c * size, o.y + r * size, size, size);
          }
        }
      } else {
        ctx.fillStyle = "#ff6b6b";
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
      // Warning
      if (o.x > w && o.x < w + 500) {
         const warnAlpha = Math.abs(Math.sin(state.timeAlive * 10)); 
         ctx.globalAlpha = warnAlpha;
         ctx.fillStyle = "#ef4444";
         const wx = w - 40;
         const wy = o.y + o.h / 2;
         ctx.beginPath();
         ctx.moveTo(wx, wy - 20);
         ctx.lineTo(wx + 20, wy + 10);
         ctx.lineTo(wx - 20, wy + 10);
         ctx.fill();
         ctx.fillStyle = "#fff";
         ctx.font = "bold 20px sans-serif";
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         ctx.fillText("!", wx, wy);
         ctx.textAlign = "start"; ctx.textBaseline = "alphabetic";
         ctx.globalAlpha = 1;
      }
    }

    // Particles
    for (const p of particles) {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Player Glow
    const glow = ctx.createRadialGradient(player.x, player.y, 10, player.x, player.y, 60);
    glow.addColorStop(0, "rgba(255, 255, 200, 0.15)");
    glow.addColorStop(1, "rgba(255, 255, 200, 0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 60, 0, Math.PI*2);
    ctx.fill();

    // Player Draw
    ctx.save();
    ctx.translate(player.x, player.y);
    let rot = 0;
    if (!player.onGround) {
       rot = Math.min(0.5, Math.max(-0.5, player.vy / 1000));
    }
    ctx.rotate(rot);

    if (horseImg.complete) {
      const drawSize = 48;
      const offset = drawSize / 2;
      ctx.drawImage(horseImg, -offset, -offset, drawSize, drawSize);

      // Wings (Smaller, Flipped, and Aligned)
      if (!player.onGround && wingsImg.complete) {
         ctx.save();
         // Pivot point on the horse's back/shoulder
         ctx.translate(-2, -12); 

         const flapSpeed = player.vy < 0 ? 25 : 12;
         const flapAngle = Math.sin(state.timeAlive * flapSpeed) * 0.5;

         ctx.rotate(flapAngle - 0.1); 
         
         // Smaller wings (30x20)
         // -25 to make the root (right side of flipped SVG) stay at the pivot point
         ctx.drawImage(wingsImg, -25, -15, 30, 20);
         ctx.restore();
      }
      
      // Super Saiyan Aura Effect
      if (player.charging) {
         const p = Math.min(1, player.chargeT / MAX_CHARGE);
         ctx.globalCompositeOperation = "lighter";
         // 1. Rising Energy
         const parts = 5 + Math.floor(p * 10);
         ctx.fillStyle = `rgba(255, 230, 100, ${0.5 + p * 0.5})`;
         for(let i=0; i<parts; i++) {
             const px = (Math.random() - 0.5) * 40;
             const py = (Math.random() - 0.5) * 40;
             const ph = 10 + Math.random() * 20 * p;
             ctx.fillRect(px, py - ph/2, 2, ph);
         }
         // 2. Aura
         ctx.beginPath();
         const auraR = 25 + p * 15;
         for (let i = 0; i <= 360; i += 20) {
            const rad = (i * Math.PI) / 180;
            const r = auraR + (Math.random() - 0.5) * 10 * p; 
            const ax = Math.cos(rad) * r;
            const ay = Math.sin(rad) * r;
            if (i===0) ctx.moveTo(ax, ay); else ctx.lineTo(ax, ay);
         }
         ctx.closePath();
         const grad = ctx.createRadialGradient(0, 0, 15, 0, 0, auraR + 10);
         grad.addColorStop(0, "rgba(255, 255, 200, 0)");
         grad.addColorStop(0.8, `rgba(255, 215, 0, ${0.4 + p * 0.4})`);
         grad.addColorStop(1, "rgba(255, 215, 0, 0)");
         ctx.fillStyle = grad;
         ctx.fill();
         // 3. Lightning
         if (p > 0.8 && Math.random() < 0.5) {
             ctx.strokeStyle = "#e0f2fe"; ctx.lineWidth = 2;
             ctx.beginPath();
             let lx = (Math.random() - 0.5) * 50; let ly = (Math.random() - 0.5) * 50;
             ctx.moveTo(lx, ly);
             for(let k=0; k<3; k++) { lx += (Math.random() - 0.5) * 20; ly += (Math.random() - 0.5) * 20; ctx.lineTo(lx, ly); }
             ctx.stroke();
         }
         ctx.globalCompositeOperation = "source-over"; 
      }

      // Blink
      if (player.isBlinking) {
         const ex = -9, ey = -7.5;
         ctx.fillStyle = "#dfa"; 
         ctx.beginPath(); ctx.arc(ex, ey, 3.5, 0, Math.PI*2); ctx.fill();
         ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
         ctx.beginPath(); ctx.moveTo(ex - 3, ey); ctx.lineTo(ex + 3, ey); ctx.stroke();
      }
    } else {
      ctx.beginPath(); ctx.fillStyle = "#7dd3fc";
      ctx.arc(0, 0, PLAYER_R, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // Charge Bar
    if (player.charging) {
      const p = Math.min(1, player.chargeT / MAX_CHARGE);
      const bw = 88, bh = 10;
      const bx = player.x - bw/2;
      const by = player.y - PLAYER_R - 26;
      ctx.fillStyle = "#0f172a"; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = "#22c55e"; ctx.fillRect(bx, by, bw*p, bh);
      ctx.strokeStyle = "#334155"; ctx.strokeRect(bx, by, bw, bh);
    }
    
    ctx.restore(); // Restore camera shake

    // UI
    if (inMenu) {
      ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#fff"; ctx.font = "700 42px system-ui, sans-serif";
      ctx.textAlign = "center"; ctx.fillText("NGỰA CHIẾN", w/2, h/2 - 50);
      drawButton(ui.startBtn, h/2 + 20);
      ctx.font = "16px system-ui, sans-serif"; ctx.fillStyle = "#cbd5e1"; ctx.textAlign = "center";
      ctx.fillText("Giữ chuột/màn hình để nạp lực nhảy.", w/2, h/2 + 110);
      ctx.textAlign = "start"; 
    }
    else if (gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#ef4444"; ctx.font = "700 48px system-ui, sans-serif";
      ctx.textAlign = "center"; ctx.fillText("GAME OVER", w/2, h/2 - 60);
      ctx.font = "24px system-ui, sans-serif"; ctx.fillStyle = "#e5e7eb";
      ctx.fillText(`Điểm: ${state.score}`, w/2, h/2 - 10);
      ctx.font = "18px system-ui, sans-serif"; ctx.fillStyle = "#9ca3af";
      ctx.fillText(`Kỷ lục: ${state.best}`, w/2, h/2 + 20);
      drawButton(ui.replayBtn, h/2 + 60);
      ctx.textAlign = "start"; 
    }
    else {
      ctx.fillStyle = "#e5e7eb";
      ctx.font = "600 18px system-ui, sans-serif";
      ctx.fillText(`Score: ${state.score}   Best: ${state.best}`, 18, 30);
    }
  }

  // ====== Loop ======
  let lastFpsTime = 0;
  let frameCount = 0;
  let fps = 60;

  function loop(now) {
    const dt = Math.min(0.033, (now - tPrev) / 1000);
    tPrev = now;
    frameCount++;
    if (now - lastFpsTime >= 1000) { fps = frameCount; frameCount = 0; lastFpsTime = now; }

    update(dt);
    draw();

    ctx.fillStyle = "#0f0"; ctx.font = "12px monospace";
    ctx.fillText(`FPS: ${fps}`, innerWidth - 60, 20);
    requestAnimationFrame(loop);
  }

  // ====== Input ======
  function press() {
    if (inMenu || gameOver) return;
    if (!player.onGround && player.canDoubleJump) {
      player.vy = -BASE_JUMP * 0.9; 
      player.canDoubleJump = false; player.charging = false;
      sfxJump();
      for(let i=0; i<5; i++) spawnDust(player.x, player.y + PLAYER_R);
      return;
    }
    if (player.onGround) { player.charging = true; player.chargeT = 0; }
  }
  function release() {
    if (inMenu || gameOver) return;
    if (player.charging && player.onGround) {
      const p = Math.min(1, player.chargeT / MAX_CHARGE);
      const boost = 1 + p * CHARGE_MULT;
      player.vy = -BASE_JUMP * boost;
      player.onGround = false; player.charging = false; player.chargeT = 0;
      state.shake = 10 * p;
      sfxJump();
    }
  }
  function checkClick(e) {
    const cx = e.clientX || (e.touches && e.touches[0].clientX);
    const cy = e.clientY || (e.touches && e.touches[0].clientY);
    const isInside = (btn) => {
      const bx = (innerWidth - btn.w) / 2; const by = btn.drawY;
      return cx >= bx && cx <= bx + btn.w && cy >= by && cy <= by + btn.h;
    };
    if (inMenu) {
      ui.startBtn.drawY = innerHeight / 2 + 20;
      if (isInside(ui.startBtn)) { startBGM(); inMenu = false; reset(); }
    } else if (gameOver) {
      ui.replayBtn.drawY = innerHeight / 2 + 60;
      if (isInside(ui.replayBtn)) { reset(); }
    }
  }

  addEventListener("mousedown", (e) => { 
    if (inMenu || gameOver) checkClick(e); else { e.preventDefault(); press(); }
  });
  addEventListener("mouseup", (e) => { 
    if (!inMenu && !gameOver) { e.preventDefault(); release(); }
  });
  addEventListener("touchstart", (e) => { 
    if (inMenu || gameOver) checkClick(e); else { e.preventDefault(); press(); }
  }, {passive:false});
  addEventListener("touchend", (e) => { 
    if (!inMenu && !gameOver) { e.preventDefault(); release(); }
  }, {passive:false});
  addEventListener("keydown", (e) => {
    if (inMenu || gameOver) {
       if (e.code === "Space" || e.code === "Enter" || e.code === "KeyR") {
          if (inMenu) { startBGM(); inMenu = false; reset(); } else reset();
       }
       return;
    }
    if (e.code === "Space" || e.code === "ArrowUp") press();
  });
  addEventListener("keyup", (e) => {
    if (!inMenu && !gameOver && (e.code === "Space" || e.code === "ArrowUp")) release();
  });

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
